---
title: "ワンタイムパスワード"
emoji: "✅"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["学習記録"]
published: false
---

# ワンタイムパスワード（One-Time Password, OTP）
- 一度しか使えない使い捨てのパスワードのことです
- OTPは数秒〜数分で無効になるため、万が一盗み見られても次の瞬間には使えなくなるという強力な特性を持っています
- 主にS/Key方式とタイムスタンプ方式です

# S/Key方式
### 事前準備
- サーバにパスワードを登録します
- シーケンス番号を設定します

### ログイン
- クライアントでidを入力する
- サーバーからseedとシーケンス番号が返さあれる。これらがチャレンジコードとなります
- クライアントが、チャレンジコードとパスワードを用いて、ハッシュ関数を使って計算します　→　OTP完成
- OTPをサーバーに送信します
- サーバーがもう一回ハッシュ関数計算を行って、計算結果と保存した結果を突き合わせます
  - 検証成功：今回認証用のOTP　H(n-1)とシーケンス番号(n-1)を保存して、次回に備えます
  - 検証失敗：ハッシュ値とシーケンス番号共に更新しません

```mermaid
sequenceDiagram
    participant User as ユーザー (Client)
    participant Server as サーバー (Server)

    Note over User, Server: 1. ログイン開始
    User->>Server: 利用者IDを送信
    
    Note right of Server: サーバーがチャレンジ(Seed, n-1)を用意
    Server->>User: シード(Seed) と シーケンス番号(n-1) を送信
    
    Note left of User: ユーザー側でハッシュ計算を実行
    Note left of User: H(n-1) = Hash^(n-1)(Pass + Seed)
    
    User->>Server: ワンタイムパスワード H(n-1) を送信
    
    Note right of Server: サーバー側で1回ハッシュで計算を加え、<br/>計算結果H(n)と保存されたハッシュ値を照合する
    alt 検証成功
        Server-->>User: ログイン許可
        Server->>Server: 次回比較用に H(n-1)とn-1 を保存
    else 検証失敗
        Server-->>User: ログイン拒否
    end
```

# タイムスタンプ方式（時刻同期方式）
- トークンと呼ばれるパスワード計算機（カード型、ソフトウェア型、キーホルダー型など）を使った方式です
- トークンとサーバーで管理するパスワードを一定時間ごとに変えることによって、毎回異なるパスワードでアクセスを可能にします
- 同期方式は時間を使っています。ある程度のずれが許容されるが、ずれすぎるとアクセスができません
### 事前準備
- 秘密鍵(K)を共有

### 処理流れ

シーケンス図は下記を設定しています

| パラメータ | 設定値 |
| :--- | :--- |
| トークン種類 | アプリ |
| ハッシュ関数 | SHA-1 |
| OTPの桁数 | 6桁 |
| 更新間隔 | 30秒 |
| 生成アルゴリズム | HMAC |

```mermaid
sequenceDiagram
    participant User as ユーザー (トークン)
    participant Server as サーバー

    Note over User, Server: 【初期設定】
    Server->>User: 秘密鍵(K)を共有 (QRコード等)
    User->>User: アプリ内に秘密鍵を保存
    Server->>Server: DBに秘密鍵を保存

    Note over User, Server: 【認証時】
    Note left of User: T = 現在時刻 / 30秒<br/>OTP = HMAC-SHA1(K, T)
    User->>Server: OTP(6桁の数字)を送信

    Note right of Server: サーバー側でも同じ計算:<br/>T' = 現在時刻 / 30秒<br/>期待値 = HMAC-SHA1(K, T')
    
    alt OTP == 期待値
        Server-->>User: 認証成功
    else 失敗
        Server-->>User: 認証失敗
    end
```

# チャレンジレスポンス
- パスワードそのものをネットワーク上に流さずに、相手が正しいパスワードを知っていることを確認します
- 「サーバーが出したお題（チャレンジ）」に対して、「クライアントが計算した回答（レスポンス）」を返すことで認証を行います

### 認証フロー
- 利用者がidとパスワードをクライアントで入力すると、ユーザーidだけを認証サーバーに送信します
- ユーザーidを受け取ったサーバーは、乱数を生成し、チャレンジコードとしてクライアントへ送信します
- チャレンジコードを受け取ったクライアントは、パスワードとチャレンジコードを基にハッシュ関数でハッシュ値を生成します
- クライアントで生成したハッシュ値をレスポンスとしてサーバーに送信します
- サーバー側は、送信したチャレンジコードと管理しているパスワードでハッシュ値を計算します
- サーバー側は、サーバーが計算したハッシュ値と送られてきたレスポンスを突き合わせてチェックします


:::message
シーケンス図は基本的な認証フローです。適用したプロトコルにより異なる点があります。
:::


```mermaid
sequenceDiagram
    participant User as クライアント
    participant Server as サーバー

    Note over User, Server: 認証フロー
    User->>Server: アクセス要求（利用者ID）
    
    Note right of Server: 一時的な乱数(R)を生成
    Server->>User: チャレンジコード (R)
    
    Note left of User: ハッシュ値を計算<br/>Response = Hash(Password + R)
    
    User->>Server: レスポンスを送信
    
    Note right of Server: サーバー側でも計算<br/>Check = Hash(Password + R)
    
    alt Response == Check
        Server-->>User: 認証成功
    else
        Server-->>User: 認証失敗
    end
```