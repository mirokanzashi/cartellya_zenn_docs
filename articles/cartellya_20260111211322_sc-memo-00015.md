---
title: "WEBセキュリティ"
emoji: "✅"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["学習記録"]
published: true
---

# HTTP通信
https://zenn.dev/cartellya/articles/cartellya_20250429160948_sc-memo-00001

# cookieとセッション
- セッション：サーバ側で利用者ごとの状態を管理する仕組みです
- cookie：セッションを維持するためにサーバとクライアント（ブラウザ）との間でやり取りされる小さなテキストデータです
- Cookieを使ってセッションを識別します
  - HTTPはステートレスのため、サーバは「誰が来たか」を覚えられないので、セッションで管理します
  - 「誰が来たか」を識別するため、CookieでセッションIDを渡す必要があります

:::message
**セッションIDの管理**
- cookieに保存します（主流）
- クエリストリング（URLパラメータ）にセッションIDを含めます
- hiddenフィールドに含めます
:::

### Cookieとセッションの典型的な連携
1. 利用者がID・パスワード送信します
2. サーバが認証成功します
3. サーバがセッション生成します
4. セッションIDをCookieで返却します
5. 以降のアクセスでCookieが自動送信します

### cookieのセキュリティ上重要な属性
| 属性 | 内容 |
| --- | ---- |
| domain | 指定したドメインとそのサブドメインに対してだけcookieを送信する。<br/>上位のドメインや別のドメインには送信されない |
| Expires | cookieの有効期限を日時でしていする。<br/>有効期限は、Max-Age属性でも指定でき、秒数で期間を指定する<br/>指定しない場合はブラウザのメモリ上のみに保存され、ブラウザを終了すると自動的に削除されます |
| Secure | HTTPS通信でのみcookieが送信される |
| HttpOnly | cookieはHTTPヘッダからのみアクセス可能になり、javascriptなどクライアント側のスクリプトからはアクセスできなくなる |
| SameSite | この属性を設定すると、クロスサイトのコンテキストでは、cookieが送信されなくなる。<br/>・Strict：クロスサイトの要求ではcookieを送信しない<br/>・Lax：クロスサイトの要求ではcookieを送信しない。<br/>　ただし、トップレベルのナビケーションではcookieを送信する<br/>・None：クロスサイトでもcookieを送信する |

# same-originポリシーとCORS(Cross-Origin Resource Sharing)
- same-origin：プロトコル、ホスト名、ポート番号がすべて一致することです
- same-originポリシー：同一オリジンの間のみアクセスが許可されます
- cors：異なるオリジン間でリソースを安全に共有するための仕組みです
  - HTTPレスポンスヘッダで指定され、サーバがリクエストに対してどのオリジンからのアクセスを許可するかを制御します

| ヘッダフィールド名 | 説明 |
| ---------------- | ---- |
| Access-Control-Allow-Origin | 異なるオリジンからのリクエストを許可するオリジンを指定 |
| Access-Control-Allow-Methods | クライアントが使用できるHTTPメソッドを指定。<br/>許可されるリクエストを制御 |
| Access-Control-Allow-Headers | クライアントがリクエストに含めることができるカスタムヘッダを指定 |
| Access-Control-Allow-Credentials | cookieや認証情報を含むリクエストを許可するかどうかを指定。<br/>これがないと、ブラウザはcookieや認証情報を含むリクエストを送信しない |

# 攻撃
## セッションハイジャック（Session Hijacking）
- 正規利用者のセッションIDを不正に取得し、その利用者になりすましてシステムにアクセスする攻撃です
- 利用者の認証状態はセッションIDによって識別されるため、セッションIDを奪われる＝本人になりすまされます

### 攻撃の手口と仕組み
**セッションIDの入手方法**
- 通信の盗聴
- 推測
- XSSでcookieを窃取
- マルウェアでローカルのcookieを窃取

**攻撃の流れ**
1. 利用者がログイン
2. セッションIDがCookieに保存
3. 攻撃者がセッションIDを入手
4. 同じセッションIDでアクセス
5. サーバは正規利用者と誤認

### 被害内容
- なりすましログイン
- 個人情報閲覧・改ざん
- 不正送金・操作
- **監査ログ上は「正規操作」**

### 対策
**Cookie属性の適切設定**
- Secure: HTTPS通信のみ
- HttpOnly: JSから参照不可
- SameSite: CSRF防止
- 有効期限設定
- domain設定

**セッション管理の対策**
- ログイン成功時に セッションID再発行
- 一定時間でタイムアウト（無効化）
- セッションIDの作成を推測しにくい方法で作成します
- IP・User-Agent変化の検知

**通信対策**
- HTTPS必須
- HSTS有効化

## セッションフィクセッション
セッションIDの固定化とも呼ばれます
攻撃者があらかじめ用意したセッションIDを被害者に使わせ、ログイン後もそのIDが有効なままになる攻撃です

### 攻撃の流れ

1. 被害者がログイン
2. セッションIDがCookieに保存
3. 攻撃者が盗聴・XSS等で取得
4. 同じIDでアクセス
5. なりすまし成功

**被害者に用意したIDを使わせる手口**
| 手段      | 説明             |
| ------- | -------------- |
| フィッシング  | メール・SMS・偽サイト誘導 |
| URL埋め込み | GETパラメータでID付与  |
| XSS     | セッションID上書き     |
| レスポンス分割 | Cookie注入       |

### 対策
権限昇格時に、既存セッションを破棄して、セッションID再生成
- ログイン成功時（無権限→権限あり）
- 管理者に昇格する時

**補助的な対策**
- セッションIDをURLに含めない
  - GETパラメータ禁止
  - Referer漏えい防止
- Cookie属性の適切設定
- セッションタイムアウト設定
- フィッシング対策（教育・DMARC等）

## HTTPヘッダーインジェクション
ユーザ入力の不適切な処理により、HTTPレスポンスヘッダに不正なヘッダや改行を注入される攻撃です

### 攻撃例
1. リクエスト：`Location: https://example.com/?id={ユーザid}`
2. 攻撃者は`abc%0d%0aSet-Cookie: SESSIONID=attacker`をidとして入力します
3. レスポンスは下記になります(任意のSet-Cookieを注入可能)

```
HTTP/1.1 302 Found
Location: https://example.com/?q=abc
Set-Cookie: SESSIONID=attacker
```

:::message
%0d%0aをエンコードするとCRLF(改行コード)になります
:::

根本的な原因はCR（`\r`）LF（`\n`）の除去・エンコードが不足です

### 被害内容
| 被害       | 内容              |
| -------- | --------------- |
| セッション固定化 | 攻撃者Cookie注入     |
| キャッシュ汚染  | Cache-Control偽装 |
| XSS      | レスポンス分割後のHTML注入 |
| リダイレクト悪用 | Location改ざん     |

### 対策
- CR/LFの除去・エンコード
- ヘッダ生成APIの使用
- ユーザ入力をヘッダに使わない
- フレームワーク最新化
- WAFでのCRLF検知


## クリックジャッキング
利用者に見えない、または誤認させたUI要素をクリックさせることで、意図しない操作を正規サイト上で実行させる攻撃です
「見ている画面」と「実際にクリックしている対象」をずらす攻撃です
:::message
操作主体：正規利用者
実行場所：正規サイト
結果：不正操作が成立
:::

**攻撃手口**
1. 攻撃者が罠ページを用意
    - 正規サイトを iframe で読み込む
    - iframeを 透明化・重ね合わせ
    ```
    <iframe src="https://bank.example/confirm"
        style="opacity:0; position:absolute; top:0; left:0;">
    </iframe>
    ```
2. 利用者を誘導
    - 「ここをクリックすると特典」
    - 「動画再生ボタン」
3. 意図しない操作が実行
    - 送金、設定変更、権限付与など
    - 正規サイト上の操作として成立

| 要因         | 説明         |
| ---------- | ---------- |
| iframe埋め込み | 他サイトに読み込める |
| UI偽装       | 透明・重ね合わせ   |
| 利用者操作      | 人がクリック     |

**対策**
- X-Frame-Optionsヘッダの設定
    - DENY: 埋め込み禁止
    - SAMEORIGIN: 同一オリジンのみ
- CSPの設定
- 重要操作の再確認

## クロスサイトスクリプティング（Cross Site Scripting, XSS）
Webアプリケーションに不正なスクリプトを注入し、利用者のブラウザ上で実行させる攻撃です
反射型・格納型・DOMベースの3種類があります

### 反射型XSS
リクエストに含まれる入力値が、そのまま**レスポンスに反映される**ことで成立するXSSです

**攻撃の流れ**
1. 攻撃者がスクリプト入りURLを作成
2. 被害者がURLをクリック
3. サーバが入力値をそのまま返却
4. ブラウザでスクリプト実行

**特徴**
- 一時的
- フィッシングと組み合わされやすい
- 典型例：検索画面の結果表示、ログイン画面のエラーメッセージ
  - `<script>alert("XSS攻撃")</script>` →実行されたら脆弱性があります

### 格納型XSS
攻撃スクリプトがサーバに**保存され**、後から閲覧した利用者全員に影響するXSSです

**攻撃の流れ**
1. 攻撃者がスクリプトを投稿
2. サーバがDB等に保存
3. 他の利用者がページ閲覧
4. スクリプト実行

**特徴**
- 永続的
- 典型例：掲示板・コメント欄、商品レビュー欄

### DOMベースXSS
**サーバを介さず**、ブラウザ上のDOM操作の不備によって成立するXSSです

**攻撃の流れ**
1. 攻撃者が細工したURLを送付
2. JavaScriptがURLやDOMを取得
3. 不適切にDOMへ反映
4. スクリプト実行

**特徴**
- サーバログに残らない
- クライアント側のみで完結
- 入力のフォームやURLのパラメータ（?以降）、URLフラグメント（#以降）を適切に処理せずにDOMへ直接反映します
- SPAで頻出
- 典型例：document.writeの利用、innerHTMLの利用, eval関数の利用

**攻撃例**
URLのパラメータをDOMに直接書き込む

```
//html内容
<p id="message"></p>

<script>
  const msg = location.hash.substring(1);
  document.getElementById("message").innerHTML = msg;
</script>

//細工されたURL
https://example.com/page.html#<script>alert('XSS')</script>
```

document.writeの例

```
//脆弱性があるコード
<script>
  document.write(location.search);
</script>

//攻撃URL
https://example.com/?<img src=x onerror=alert(1)>

```

### 対策（共通）
- 出力時エスケープ（サニタイジング）
- HttpOnly Cookie
- CSP（Content Security Policy）

## CSRF（Cross-Site Request Forgery）
利用者がログイン中の正規Webサービスに対して、第三者のサイトから意図しないリクエストを送信させる攻撃です

### 成立条件
- 利用者が対象サイトにログイン中
- 認証にCookieを使用
- 状態変更リクエストにCSRF対策がありません

### 攻撃手口
- 特徴
  - 被害者は何も「怪しい操作」をしていません
  - サーバ側は「Cookieが正しい＝正規利用者の操作」と誤認します
  - 被害者が意図的な操作ではありません

**手順**
1. 被害者が正規サイトにログイン
    - 認証Cookieがブラウザに保存されて、セッションは有効なまま
2. 攻撃者が罠サイトを用意します

```
//例1
<form action="https://service.example/change_email" method="POST">
  <input type="hidden" name="email" value="attacker@example.com">
</form>
<script>
  document.forms[0].submit();
</script>

//例2
<img src="https://service.example/delete?id=123">

```

3. 被害者が罠サイトを閲覧
    - SNS、メール、掲示板などで誘導（フィッシングなど）
    - 被害者はただページを開いただけ
4. ブラウザが自動でリクエスト送信
    - 正規サイト宛のリクエストを送信して、認証Cookieも自動的に付与
5. サーバが正規操作と誤認
    - Cookieが正しい + リクエスト形式も正しい → 不正操作が成立

```
被害者のブラウザ
 ├ 正規サイトのCookieを保持
 └ 攻撃者の用意したリクエストを送信
```

**根本原因**
| 原因         | 説明             |
| ---------- | -------------- |
| Cookie自動送信 | ブラウザ仕様         |
| 意思確認なし     | リクエスト元の正当性未確認  |
| トークン未使用    | 利用者操作と結びついていない |


### 対策
**CSRFトークン利用**
- サーバが 推測困難なランダム値（トークン）を生成し、画面側のフォームやリクエストに埋め込みます
- リクエストされる時、サーバ側がトークンを検証します
- 画面遷移の連続性を確認可能です

**SameSite Cookie属性を指定する**
クロスサイトからのCookie送信を制限します


| 値      | 挙動             |
| ------ | -------------- |
| Strict | クロスサイト送信禁止     |
| Lax    | 一部制限（GET遷移など）  |
| None   | 制限なし（Secure必須） |

```
Set-Cookie: session=abc; SameSite=Lax
```

**Referer / Originヘッダ検証**
- 仕組み
  - リクエスト元のオリジンを確認
  - 正規ドメイン以外を拒否
- 限界
  - ヘッダ欠落・偽装の可能性
  - プライバシー設定の影響

**追加確認**
重要な操作を実行する前に、再度操作に対してユーザの確認を求めます
- パスワード再入力
- ワンタイムパスワード
- CAPTCHA

## オープンリダイレクト攻撃（Open Redirect）
Webアプリケーションが利用者の指定した任意のURLへ無制限にリダイレクトしてしまう脆弱性です
正規サイトを経由して、攻撃者の用意したサイトへ誘導できてしまいます

**攻撃手口**
1. 攻撃者がURLを細工 `https://example.com/login?redirect=https://evil.example`
2. 被害者がリンクをクリック
3. 攻撃者サイトへ転送
    - フィッシング
    - マルウェア配布
    - セッション奪取の踏み台

悪い実装例：リダイレクト先を無検証で使用
```
redirect_to(request.get("redirect"))
```

**対策**
- リダイレクト先をホワイトリスト管理して、固定URLのみ許可します
- 相対パスのみ許可します
- 正規表現による厳格チェックします。例： `https://trusted.example/*`
- デフォルト遷移先を固定して、パラメータ未指定時は安全なページへ遷移します

# CSP(Content Security Policy)
「どこから・何を読み込んでよいか」をブラウザに宣言するセキュリティポリシーです
```
Content-Security-Policy: ディレクティブ 値;
```

| ディレクティブ                       | 主な用途                  | 防げる攻撃・問題     | 補足         |
| ----------------------------- | --------------------- | ------------ | ----------------- |
| **default-src**               | すべての未指定リソースの既定取得元     | 設定漏れによる想定外読込 | 最初に厳しく設定          |
| **script-src**                | JavaScriptの読込・実行制御    | XSS          | nonce/hash併用  |
| **style-src**                 | CSSの読込制御              | CSS注入        | `unsafe-inline`原則禁止 |
| **img-src**                   | 画像読込制御                | 情報漏えい        | `data:` 許可有無      |
| **connect-src**               | Ajax / Fetch / WS 通信先 | 不正通信         | API接続制御           |
| **frame-ancestors**           | iframe 埋め込み元制御        | クリックジャッキング   | どのサイトからiframe埋め込みを許可するか<br/>X-Frame-Options後継 |
| **frame-src**                 | iframe 内読込先           | 不正画面表示       | 広告・外部連携           |
| **form-action**               | フォーム送信先制限             | CSRF補助       | トークン併用            |
| **object-src**                | プラグイン制御               | 旧式脆弱性        | 原則 `'none'`       |
| **media-src**                 | 音声・動画取得元              | 不正配信         | 動画配信制御            |
| **font-src**                  | Webフォント取得元            | 情報漏えい        | CDN使用時注意          |
| **base-uri**                  | `<base>`タグ指定先         | URL書換攻撃      | 見落としやすい           |
| **upgrade-insecure-requests** | HTTP→HTTPS強制          | 中間者攻撃        | HTTPS移行補助         |
| **block-all-mixed-content**   | 混在コンテンツ禁止             | MITM         | HTTPSページでのHTTPリソース禁止<br/>HTTPS専用           |
| **report-to**                 | CSP違反通知               | 侵害検知         | 監査用途              |

### 使用例
- nonce / hash：`script-src 'nonce-abc123';` (インラインスクリプトを安全に許可)
- `frame-ancestors 'self';`
- `frame-src https://trusted.example;`（iframe 内で読み込めるリソース）
- `script-src 'self' https://cdn.example;`



# その他WEBサーバ全般の対策
## 重要なファイルを公開ディレクトリに置かない
- 検索エンジンに引っ掛かった恐れがあります
- ディレクトリトラバーサル攻撃される恐れがあります

## HTTP認証
プロトコルレベルの認証です
### Basic認証
ユーザ名とパスワードをBase64で符号化して送信する方式であり、暗号化されていないためHTTPSでの利用が前提となります
**特徴**
- ユーザ名:パスワードをBase64エンコード
- 暗号化ではないので、TLS（HTTPS）前提でなければ危険です

**仕組み**
- クライアントがリソース要求
- サーバが 401 Unauthorized を返却
- クライアントが資格情報を送信

```
Authorization: Basic dXNlcjpwYXNzd29yZA==
```

### Digest認証
サーバから提示されたnonceを用いたチャレンジレスポンス方式により、パスワードそのものを送信しないHTTP認証方式です
**特徴**
- パスワードそのものは送信しない
- チャレンジレスポンス方式
- MD5の安全性問題と、TLSの標準化・高速化、OAuth / OpenID Connect等の普及により、あまり使用されていません
- 現代WebはTLS＋トークン認証が主流です

**仕組み**
1. サーバが nonce（ランダム値）を提示
2. クライアントが次を計算 `MD5(username:realm:password)`
3. nonce等と組み合わせた ハッシュ値を送信


## WAF(Web Application Firewall)の導入

